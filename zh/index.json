[
{
	"uri": "https://deemopoi.github.io/zh/b03-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/1-%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8/",
	"title": "1 汇编介绍",
	"tags": [],
	"description": "",
	"content": "1 汇编语言的由来 什么是机器语言\n# 我们目前主流的电子计算机 状态： 0 和 1 # 最早的程序员，穿孔卡带 加 0100 0000（瞎写的） 减 0100 1000 乘 0100 1000 0100 1000 除 0100 1000 1100 1000 这些复杂的机器语言，能简化吗？\n助记符！**汇编语言！**把人类能够理解的语言，用编译器，转换为机器能够理解的语言\n加 INC --编译器--\u0026gt; 0100 0000 减 DEC 0100 1000 乘 MUL 0100 1000 0100 1000 除 DIV 0100 1000 1100 1000 汇编一般用于底层的编写，单片机，暴力破解，外挂。。。\n C语言\n加 + --编译器--\u0026gt; 0100 0000 减 - 0100 1000\r乘 * 0100 1000 0100 1000\r除 / 0100 1000 1100 1000\r之后才诞生了C++\nPython，Java\n。。。\n"
},
{
	"uri": "https://deemopoi.github.io/zh/b01-java%E5%85%A5%E9%97%A8/1-dos%E5%91%BD%E4%BB%A4/",
	"title": "1 DOS命令",
	"tags": [],
	"description": "",
	"content": "1 打开CMD的方式  在任意文件夹下面，按住 shift+鼠标右键，可以在此处打开powershell 在资源管理器的地址栏，前面加上 cmd+空格，可以在此地址打开cmd  2 常用DOS命令 # 基本操作 \u0026gt;D: (盘符切换) \u0026gt;dir (directory) \u0026gt;cd (change directory) \u0026gt;cd.. (返回上一级) \u0026gt;cls (clear screen) \u0026gt;md (make directory) \u0026gt;rd (remove directory) \u0026gt;cd\u0026gt;text.txt (创建文件) \u0026gt;del text.txt (删除文件) \u0026gt;ipconfig (查看电脑ip) \u0026gt;选中后回车 (复制) \u0026gt;右键 (粘贴，有些不可以用 Ctrl + V 粘贴) # 打开应用 \u0026gt;calc (calculator) \u0026gt;mspaint (画图工具) \u0026gt;notepad # ping 命令 \u0026gt;ping www.baidu.com "
},
{
	"uri": "https://deemopoi.github.io/zh/b03-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/2-%E8%BF%9B%E5%88%B6-%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0-%E4%BD%8D%E8%BF%90%E7%AE%97/",
	"title": "2 进制 有符号数 位运算",
	"tags": [],
	"description": "",
	"content": "1 进制 二进制: 0 1111 0 1 10 11 100 101 110 111 1000 1001 1010 1011 1100 1101 1110 1111 二进制这么去写很麻烦，能否简写？16进制！\n0 1 2 3 4 5 6 7 8 9 a b c d e f 为什么学习二进制？\n寄存器、内存、位！底层的每一个位都是有含义的，汇编入门理解的基础。\n汇编高级：了解程序的深层！操作系统的内核\n2 数据宽度 C ，C++，Java 都需要定义数据的类型。计算机底层需要我们给这些数据定义宽度。\n   位 bit 0 1     字节 Byte 0-0xFF   字 Word 0-0xFFFF   双字 DWORD 0-0xFFFFFFFF    在计算机中，每一个数据都需要给它定义类型，也就是定义宽度，在内存中的宽度。\n3 有符号数 无符号数 数据都是有宽度的。每个数据代表什么意思？\n1 0 0 1 1 0 1 0 类似于mp3音乐文件，就以特定的格式（规则），解码\n规则，二进制解码增加一个规则？\n无符号规则\n你这个数字是什么，那就是什么\n1 0 0 1 1 0 1 0 十六进制： 0x9A 十进制：154 有符号规则\n最高位是 符号位：1（负数） 0（正数）\n1 0 0 1 1 0 1 0 如何转换？ 4 原码反码补码 有符号数的编码规则\n**原码：**最高位是符号位，对于其他的位，取本身绝对值即可。\n反码：\n 正数：反码和原码相同 负数：符号位一定是1，其余位原码取反  补码：\n 正数：补码和原码相同 负数：符号位一定是1，反码+1   测试\n # 现在我说的这些都是 8 位 # 如果是正数，这些都是一样的 1 #原码 0 0 0 0 0 0 0 1 #反码 0 0 0 0 0 0 0 1 #补码 0 0 0 0 0 0 0 1 # 如果是负数 -1 #原码 1 0 0 0 0 0 0 1 #反码 1 1 1 1 1 1 1 0 (开头是1，其余取反) #补码 1 1 1 1 1 1 1 1 (开头是1，反码+1) -7 #原码 1 0 0 0 0 1 1 1 #反码 1 1 1 1 1 0 0 0 #补码 1 1 1 1 1 0 0 1 #二进制的计算，记住二进制的几个标志 2 10 4 100 8 1000 16 10000 如果看到一个二进制数，例如 1 1 1 1 1 1 1 1 ，需要了解它是有符号数还是无符号数\n**寄存器：**通过 mov 指令存值 （正数是正常的数，负数则是用补码存放）\n5 位运算 计算机现在可以存储所有的数字（整数，浮点数，字符）。\n如果可以加以运算，就有无限可能了。\n1011 0001 1101 1000 ----------- 与运算 and (都是1，才取1) 1001 0000 ----------- 或运算 or (存在1，就取1) 1111 1001 ----------- 异或运算 xor (不同才取1) 0110 1001 ----------- 非运算 not (单目运算符，取反) 0100 1110 0010 0111 通过这些，就可以实现加减乘除！\n5.1 位运算（移动位） 左移: (shl \u0026laquo;)\n0000 0001 # 所有二进制位全部左移若干位，高位丢弃，低位补0 0000 0010 右移: (shr \u0026raquo;)\n0000 0001 # 所有二进制位全部右移若干位，低位丢弃，高位补0，1（由符号位决定） 0000 0000 5.2 位运算的加减乘除 计算机只认识 0 1，以及下面的 与，或，非，异或 电路\n基本数学是建立在 加减乘除 上的\n4 + 5 = ?\n0000 0100 0000 0101 ----------- (加法，计算机是不会直接加的) 0000 1001 # 计算机是怎么操作的？ # Step1 异或运算，如果不考虑进位，异或就可以直接出结果 0000 0100 0000 0101 ----------- 0000 0001 # Step2 与运算（判断进位，如果与运算结果为0，就说明没有进位，得出结果） 0000 0100 0000 0101 ----------- 0000 0100 # Step3 如果Step2有进位，将与运算的结果，左移一位（进位） 0000 1000 # 进位的结果 # Step4 异或运算，将Step1的异或结果，与Step3的进位结果，进行异或 0000 0001 0000 1000 ----------- 0000 1001 # Step5 与运算（判断进位，如果结果为0，表示没有更多的进位，就得出结果） 0000 0001 0000 1000 ---------- 0000 0000 # 所以最终结果就是与运算为0的结果的上一个异或运算结果 0000 1001 4 - 5 = ?\n# 本质是加法： 4 + (-5) # 5 0000 0101 # -5 1111 1011(补码，开头为1，其余取反，再+1) 0000 0100 1111 1011 ----------- 1111 1111 ff 在计算机里代表-1 # 计算机是怎么操作的？ # Step1 异或运算，如果不考虑进位，异或就可以直接出结果 0000 0100 1111 1011 ----------- 1111 1111 # Step2 与运算（判断进位，如果与运算结果为0，就说明没有进位，得出结果） 0000 0100 1111 1011 ----------- 0000 0000 # 没有进位，最终结果就是异或运算的结果 1111 1111 乘法：x * y， 就是 y 个 x 相加，本质还是加法\n除法：x / y，就是 x 能减去多少个 y，本质还是加法\n计算机只会做加法\n"
},
{
	"uri": "https://deemopoi.github.io/zh/b01-java%E5%85%A5%E9%97%A8/2-java%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%AE%89%E8%A3%85/",
	"title": "2 Java介绍和安装",
	"tags": [],
	"description": "",
	"content": "1 语言历史   机器语言\n  汇编语言\n  C语言 (贴近硬件、运行极快、效率极高 | 指针和内存管理)\n  C++ (面向对象、兼容C | 但更复杂)\n   | 有点像C | 没有指针和内存管理 | 真正可移植性，编写一次，到处运行 |\n| 面向对象 | 类型安全 | 高质量的类库 |\nJava (2006: Hadoop 大数据领域 | 2008: Android 手机端)  2 Java介绍 2.1 特性 | 简单 | 面向对象 | 可移植性，跨平台| 高性能 | 分布式 |\n| 动态性 | 多线程 | 安全性 | 健壮性 |\n2.2 三大版本 JavaSE 标准版（桌面程序，控制台开发）\nJavaME 嵌入式开发（手机，小家电）\nJavaEE 企业级开发（web端，服务器开发）\n2.3 JDK, JRE, JVM JDK Java Development Kit (包含JRE)\nJRE Java Runtime Environment (包含JVM)\nJVM Java Virtual Machine (用它实现 Write once, run anywhere. )\n 2.4 安装 JDK 安装指导\n下载地址\n可以一次性安装好 JDK、IntelliJ、Git 并帮你配置好环境\n2.5 卸载 JDK 针对上面的安装方式：\n  To uninstall everything, navigate to C:\\Program Files\\LIFT-CS and launch the uninstaller unins000.exe. To uninstall only IntelliJ, navigate to C:\\Program Files (x86)\\JetBrains\\IntelliJ IDEA Community Edition 2020.1\\bin; right click the uninstaller Uninstall.exe; and select Run as administrator.   针对一般的安装方式：\n  删除Java的安装目录 删除环境变量中的JAVA_HOME (如果有) 删除path下关于Java的目录 cmd \u0026gt;java -version 确认是否卸载   2.6 Java程序运行机制 编译型：\n一次性编译完，负责编译的东西叫编译器 (操作系统 | 比较快 | 例如 C/C++)\n解释型：\n一边解释一边运行 (网页、服务器 | 对速度要求不高 |例如 JAVA )\n Java程序运行时，先通过编译器编译成了class文件，然后进入 JVM 里面，校对后，通过解释器，一边解释一边运行。\n 2.7 注释 // 单行注释  /* 多行注释 */ /** 文档注释 * @author * @version * @since 指明需要最早使用的JDK版本 * @param 参数名 * @return * @throws */ "
},
{
	"uri": "https://deemopoi.github.io/zh/b03-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/3-%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/",
	"title": "3 汇编学习指南",
	"tags": [],
	"description": "",
	"content": "1 学习指南 通过汇编指令，可以给计算机发一些操作，然后让计算机执行，编译器。如果学底层，千万别用很智能的编译器，底层的大佬几乎都是用最原始的IDE学习汇编的。\n 很多人学C，都用linux学C，直接用vim编辑器写C，通过gcc来执行\n 学习汇编之前，大家需要先掌握环境配置：\n VC6（写C++的话，建议用 VC6 学汇编，别用Java去学汇编） OD（我爱破解） 抓包工具（学计算机网络的话） 加密解密工具  学完汇编以后，再去学JVM，会觉得很简单\n 学汇编不是为了写代码，而是为了理解程序的本质。\n 学习资料\n《汇编语言》 16位的汇编，但是现在的操作系统都是32位的，或者基于32位的64位\n建议直接学习32位汇编！\n"
},
{
	"uri": "https://deemopoi.github.io/zh/b01-java%E5%85%A5%E9%97%A8/3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97/",
	"title": "3 数据类型和运算",
	"tags": [],
	"description": "",
	"content": "1 数据类型 1.1 强类型语言： (例如 Java | 速度慢些) 要求变量的使用要严格符合规定，所有变量都必须先定义后才能使用\n1.2 弱类型语言： (例如 VB, JS) 1.3 Java的数据类型分为两大类： 基本类型 (primitive type)\n// integer byte num1 = 10; // 1 byte (-128, 127) short num2 = 20; // 2 bytes (-32768, 32767) int num3 = 30; // 4 bytes (-2,147,483,648, 2,147,483,647) long num4 = 40L; // 8 bytes (-2^63, 2^63 -1)  // decimal float num = 50.1f; // 4 bytes 避免用float进行比较 double num = 3.141592653; // 8 bytes  // character char name = \u0026#34;A\u0026#34;; // one character, 2 bytes (0, 65535)  // boolean boolean flag = true; // 默认初始化是false, 1 bit 引用类型 (reference type)\n 除了8大基本类型，其余基本都是引用类型\n  对象是通过引用(地址)来操作的：地址在 栈 里面，而真实对象在 堆 里面\n  默认初始化值都是 null\n  每个地址占了8 bytes\n // array // ... // String 2 数据类型的转换 /* 低 byte,short,char -\u0026gt; int -\u0026gt; long -\u0026gt; float -\u0026gt; double 高 */ /** 注意点： * 1. 不能对布尔值进行转换 * 2. 不能把对象类型转换为不相干的类型 * 3. 在把高容量转换到低容量的时候，强制转换 * 4. 转换的时候可能存在内存溢出，或者精度问题 */ int i = 127; double = i; //自动转换 低-\u0026gt;高 byte = (byte)i; //强制转换 高-\u0026gt;低  int money = 1_000_000_000; // JDK7的新特性，数字可以用下划线分割 int years = 20; int total = money * years; // 溢出 long total2 = money * years; // 还是溢出，因为转换之前已经溢出了 long total3 = money * ((long)years); // 不溢出  long a = 123123123123123L; int b = 123; short c = 10; byte d = 8; System.out.println(a + b + c + d); // long System.out.println(b + c +d); // int System.out.println(c + d); // int 如果不是比int高，那么默认是int  char c = \u0026#39;a\u0026#39;; int n = c + 1; // 自动转换，低-\u0026gt;高，得到\u0026#39;a\u0026#39;对应的数字 + 1 char c2 = (char)n ; // 强制转换，高-\u0026gt;低，得到字母\u0026#39;b\u0026#39; 3 运算符 // ++ -- 自增 自减 int a = 3; int b = a++; // a先赋值给b，再自增1 int c = ++a; // a先自增1，再赋值给c System.out.println(a); // 5 System.out.println(b); // 3 System.out.println(c); // 5  // 短路运算 int c = 5; boolean d = (c \u0026lt; 4) \u0026amp;\u0026amp; (c++ \u0026lt; 4); // \u0026amp;\u0026amp; 左边是false，右边根本不会执行 System.out.println(d); // false System.out.println(c); // 5  // 位运算 \u0026amp; | ^ ~ \u0026gt;\u0026gt; \u0026lt;\u0026lt; (涉及到计算机组成原理) /* A = 0011 1100 B = 0000 1101 A\u0026amp;B = 0000 1100 类似and，都是1，才取1 A|B = 0011 1101 类似or,存在1，就取1 A^B = 0011 0001 异或，不同才取1 ~B = 1111 0010 取反 ########################### \u0026lt;\u0026lt; 左移 *2 \u0026gt;\u0026gt; 右移 /2 0000 0000 0 0000 0001 1 0000 0010 2 0000 0100 4 0000 1000 8 0001 0000 16 */ System.out.println(2\u0026lt;\u0026lt;3); //16 2在二进制下，将1向左移动3位，变成16  // 字符串连接符 int a = 10; int b = 20; System.out.println(\u0026#34;\u0026#34; + a + b); // 1020 只连接 System.out.println(a + b + \u0026#34;\u0026#34;); // 30 先运算再连接  // 条件运算符 // x ? y : z // 如果 x == true，则结果为y，否则结果为z int score = 50; String result = score \u0026lt; 60 ? \u0026#34;不及格\u0026#34; : \u0026#34;及格\u0026#34;; System.out.println(result); // 及格  4 变量 public class Demo { // 类变量 static 不用new对象也可以直接使用  static double salary = 2500; // 实例变量 instance variable  String name; int age; // 常量 constant，初始化(initailize)之后不能再改变的值  final double pi = 3.1415; public static void main(String[] args) { // 局部变量  int i = 0; // 类变量的用法  System.out.println(salary); // 实例变量的用法  // 变量类型 变量名 = new Demo();  Demo de = new Demo(); System.out.println(de.age); System.out.println(de.name); } } "
},
{
	"uri": "https://deemopoi.github.io/zh/b03-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/4-%E5%AF%84%E5%AD%98%E5%99%A8-%E5%86%85%E5%AD%98/",
	"title": "4 寄存器 内存",
	"tags": [],
	"description": "",
	"content": "1 通用寄存器 存储数据：CPU \u0026gt; 内存 \u0026gt; 硬盘\n32位CPU 8 16 32\n64位CPU 8 16 32 64\n通用寄存器，可以存储任意的东西\n# 32位的通用寄存器只有8个，存值的范围（0-FFFFFFFF） 计算机如何向寄存器里存值\n对于二进制来说，直接修改值\n对于汇编，用 mov 指令\nmov 存的地址,存的数 （可以将数字写入寄存器） mov 写入地址1,从地址2 （可以将寄存器中的值写到寄存器） 不同的寄存器\nFFFFFFFF FFFF FF 0000 0000 32 位 16位 8位 EAX AX AL ECX CX CL EDX DX DL EBX BX BL ESP SP AH ENP NP CH ESI SI DH EDI DI BH 8位：L 低8位， H 高8位 （高8位+低8位，也是16位的状态）\n除了这些通用寄存器之外，其他的寄存器每一位都有自己特定的功能。\n2 内存 寄存器很小，而且不够用，于是我们都把数据放到内存中。\n32位的寻址能力：\nF 代表 1111，4bits\n8个F就是，32bits (位)\n内存地址：0x00000000 - 0xFFFFFFFF = 0x1 0000 0000 个内存地址\n每个内存地址可以容纳1个Byte 0000 0000  的数据\n0x1 0000 0000 个Bytes，转换为10进制 = 4,294,967,296 Bytes(字节 B) 的数据量\n按照规则 /1024，B \u0026ndash;\u0026gt; KB \u0026ndash;\u0026gt; MB \u0026ndash;\u0026gt; GB 最终发现就是 4GB！\n这就解释了为什么32位的CPU最大只支持4GB内存！\n而64位的寻址能力： 0x00000000 00000000 - 0xFFFFFFFF FFFFFFFF 绰绰有余！\n所以每个内存地址都有一个编号，可以通过这些编号往里面存值。\n内存如何存值？\n数据宽度：\n Byte(0xFF) 8 bits (位) Word(0xFFFF) 16 bits DWORD(0xFFFFFFFF) 32 bits QWORD(0xFFFFFFFF FFFFFFFF) 64 bits  内存地址：0xFFFFFFFF\n不是任意的地址都可以写东西，只有程序申请过的内存地址才可以使用。\n# 汇编如何向内存中写值 mov 数据宽度 ptr ds:[内存地址], 值 mov byte ptr ds:[0x0019FF70], 1 mov dword ptr ds:[0x0019FF74], 1 # 注意传递的值的大小，一定要在数据宽度以内 # 内存地址有多种写法 ds:[0x0019FF70+4] # 内存地址偏移写法，其实就是 ds:[0x0019FF74] ds:[eax] # 寄存器写法，就是把寄存器里的值放到内存里面 ds:[eax+4] # 寄存器偏移写法 # 数组[] ds:[reg+reg*{1,2,4,8}] ds:[reg+reg*{1,2,4,8}+4] # 偏移 "
},
{
	"uri": "https://deemopoi.github.io/zh/b01-java%E5%85%A5%E9%97%A8/4-%E8%AF%AD%E6%B3%95%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/",
	"title": "4 语法查漏补缺",
	"tags": [],
	"description": "",
	"content": "1 用户交互 Scanner // next() 会跳过空格，并把空格作为分隔符，所以输出不会带有空格 // nextline() 会读取整行，遇到enter时停止读取，所以输出可以带空格 // hasNext() 与 hasNextline() 等待输入数据，返回boolean  import java.util.Scanner; public class Demo { public static void main(String[] args) { // 创建一个扫描器对象，用于接收键盘数据  Scanner scanner = new Scanner(System.in); System.out.println(\u0026#34;请输入数据：\u0026#34;); // 程序会在此处暂停，直到用户输入  String str = scanner.next(); System.out.println(\u0026#34;输出的内容为：\u0026#34; + str); // 凡是属于IO流的类，如果不关闭会一直占用资源  scanner.close(); } } 2 多选择结构 switch char grade = \u0026#39;C\u0026#39;; //switch 匹配一个具体的值，每个case都需要break，否则会继续执行 //JDK7 以后，支持匹配字符串 String 了 switch (grade) { case \u0026#39;A\u0026#39;: System.out.println(\u0026#34;优秀\u0026#34;); break; case \u0026#39;B\u0026#39;: System.out.println(\u0026#34;良好\u0026#34;); break; case \u0026#39;C\u0026#39;: System.out.println(\u0026#34;及格\u0026#34;); break; case \u0026#39;F\u0026#39;: System.out.println(\u0026#34;挂科\u0026#34;); break; default: System.out.println(\u0026#34;未知等级\u0026#34;); } 3 语法查漏 // 判断字符串是否相等不能用 == ，而用 .equals() String s = \u0026#34;Hello\u0026#34;; if (s.equals(\u0026#34;Hello\u0026#34;)) { } // do while 先执行后判断，至少执行一次 do { sum += i; i++; }while (i \u0026lt;= 100); // 遍历数组内的元素 int[] numbers = {10,20,30,40,50}; for (int i : numbers) { System.out.println(i); } // 反转数组内元素 int len = numbers.length; int [] reuslt = new int[len]; for (int i = 0, j = len-1; i \u0026lt; len; i++, j--) { result[j] = numbers[i]; } System.out.println(result); // break 强制退出loop // continue 中断本次loop，执行下次loop "
},
{
	"uri": "https://deemopoi.github.io/zh/b01-java%E5%85%A5%E9%97%A8/5-%E6%96%B9%E6%B3%95%E5%92%8C%E6%95%B0%E7%BB%84/",
	"title": "5 方法和数组",
	"tags": [],
	"description": "",
	"content": "1 method public class Student { // 静态方法，跟class一起加载的，直接调用  public static void say() { System.out.println(\u0026#34;学生说话了\u0026#34;); } // 实例方法，实例化以后才能调用  public void run() { System.out.println(\u0026#34;学生跑了\u0026#34;) } } // method 的名字可以相同，但参数列表要不同  public class Demo { // static 无需实例化，能够直接调用  public static int plus(int a, int b) { return a + b; } // 需要实例化才能调用  public int minus(int a, int b) { return a - b; } // (数量)可变参数  public static void printMax(double... numbers) { double result = numbers[0]; // 排序  for (int i = 1; i \u0026lt; numbers.length; i++) { if (number[i] \u0026gt; result) { result = number[i]; } } System.out.println(\u0026#34;The maximum value is \u0026#34; + result); } public static void main(String[] args) { // ####调用内部方法####  // static方法，直接调用  int sum = plus(2, 3); // 实例化以后调用  Demo de = new Demo(); int deff = de.minus(5, 2); // 可传入任意数量参数  de.printMax(32, 71.1, -8.3, 52); // ####调用外部方法####  // static方法，直接调用  Student.say(); // 实例化以后调用  Student stu = new Student(); stu.run(); } } 2 array // 数组长度是确定的，一旦被创建，大小不可改变 // 元素的类型必须是相同的，不能混用 // 元素可以是任何数据类型，包括基本类型和引用类型 // 数组变量属于引用类型，数组可以看成是对象，数组中的元素相当于这个对象的成员变量 // 数组作为对象(被new出来的)，是在堆中的  // 静态初始化 int[] a = {1,2,3,4,5}; // 动态初始化 // 包含默认初始化(String类型的默认元素是null,int默认是0) int[] nums; // 声明 nums = new int[10]; // 创建(初始化)  int[] nums = new int[10]; // 声明 + 创建  int[] nums = new int[]{1,2,3,4,5}; // 声明 + 创建 + 赋值  // 二维数组 int[][] array = new int[5][2]; int[][] array = {{1,2},{2,3},{3,4},{4,5},{5,6}}; // 遍历二维数组内的元素 for (int i = 0; i \u0026lt; array.length; i++) { for (int j = 0; j \u0026lt; array[i].length; j++) { System.out.println(array[i][j]); } } 3 内置的 Array 类方法 import java.util.Arrays; public class Demo { public static void main(String[] args) { int[] a = {2, 4, -47, 19, -53, 21}; System.out.println(a); // 直接print数组，会输出 哈希值  // 打印数组元素 Arrays.toString  System.out.println(Arrays.toString(a)); // 对数组内元素排序(升序) Arrays.sort  Arrays.sort(a); System.out.println(Arrays.toString(a)); // 给数组填充 Arrays.fill(array,val)  // Arrays.fill(array,fromIndex,toIndex,val)  Arrays.fill(a,0); // 所有元素被0填充  Arrays.fill(a,2,4,0); // index 2 - 4 的元素被0填充  System.out.println(Arrays.toString(a)); /** 其他常用方法(可查看JDK帮助文档)： * 比较数组：equals 方法，比较数组中元素是否相等 * 查找数组元素： binarySearch 方法，对排序好的数组进行二分查找 */ } } "
},
{
	"uri": "https://deemopoi.github.io/zh/b01-java%E5%85%A5%E9%97%A8/6-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/",
	"title": "6 面向对象",
	"tags": [],
	"description": "",
	"content": "1 面向对象概念 **面向对象编程的本质：**以类的方式组织代码，以对象的组织（封装）数据\n三大特性：\n  封装\n  继承\n  多态\n   从认知的角度考虑，是先有对象后有类。对象，是具体的事物；类，是抽象的，是对象的抽象。\n  从代码的角度考虑，是先有类后有对象。类是对象的模板，对象是类的实例。\n 2 类 和 对象 // Student类 public class Student { // 属性：字段（这里不赋值，实例化以后才赋值）  String name; // null  int age; // 0  // 方法  public void study() { // this. 指的是本class内部的  System.out.println(this.name + \u0026#34; is learning.\u0026#34;); } } // 主类 public class Application { // 主类才有main方法  public static void main(String[] args) { // 把Student这个 类 实例化为 对象  Student tom = new Student(); Student mary = new Student(); // 把tom内的属性进行赋值  tom.name = \u0026#34;Tom\u0026#34;; tom.age = 7; System.out.println(tom.name); // Tom  System.out.println(tom.age); // 7  System.out.println(mary.name); // null  System.out.println(mary.age); // 0  } } 3 构造器 构造器 constructor：\n 和类名同名 没有返回值  作用：\n new 本质是在调用构造器 初始化 对象的值  IDEA 快捷键： Alt + insert\npublic class Person { String name; int age; // ########隐式的定义构造器########  // 一个类即使什么都不写，也会存在一个方法,与类名 Person 同名  // public Person() {  // }  // ########显式的定义构造器########  // 无参构造器，new(实例化)一个对象的时候，不用传递参数  public Person() {、 // 里面也可以什么都不写  this.name = \u0026#34;Tom\u0026#34;; this.age = 7; } // 有参构造器，要传递参数  // 一旦定义了有参构造器，无参构造器就必须 显式定义  public Person(String name, int age) { this.name = name; this.age = age; } } 4 内存分析 5 参数传递vs引用传递 // 参数传递 public class Demo { public static void changeNum(int a) { a = 10; } public static void main(String[] args) { int a = 1; System.out.println(a); // 1  // 只传参（只复制a的值），a本身不变  Demo.changeNum(a); // Demo. 可以省略  System.out.println(a); // 1  } } // 引用传递 public class Demo { // class内部的class  private class Person { String name; } public static void changeName(Person p) { p.name = \u0026#34;Tom\u0026#34;; } public static void main(String[] args) { // 实例化class  Person p = new Person(); System.out.println(p.name); // null  // 传递 p 这个实例化了的对象（复制了地址），所以会改变内部name  Demo.changeName(p); // Demo. 可以省略  System.out.println(p.name); // Tom  } } "
},
{
	"uri": "https://deemopoi.github.io/zh/b01-java%E5%85%A5%E9%97%A8/7-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_%E5%B0%81%E8%A3%85-%E7%BB%A7%E6%89%BF-%E5%A4%9A%E6%80%81/",
	"title": "7 面向对象_封装 继承 多态",
	"tags": [],
	"description": "",
	"content": "1 封装 1.1 该露的露，该藏的藏 **高内聚：**类的内部数据操作细节自己完成，不允许外部干涉。\n**低耦合：**仅暴露少量的方法给外部使用。\n1.2 封装（数据的隐藏） 禁止直接访问一个对象中数据的实际表示，而应该通过操作接口来访问，称为信息隐蔽。\n1.3 属性私有，get/set 重点对于属性，而不是方法。\nIDEA快捷键： Alt + insert\n1.4 总结  提高程序的安全性，保护数据 隐藏代码的实现细节 统一接口，形成规范 增加系统的可维护性  public class Student { // 属性私有，无法直接外部调用了  private String name; private int id; private char gender; private int age; // 提供一些可操作这个属性的方法!  // 提供一些public 的 get/set 方法  // get 获取这个数据  public String getName() { return this.name; } // set 给这个数据设置值  public void setName(String name) { this.name = name } // 可以对输入数据设一些限制  public void setAge(int age) { if (age \u0026gt; 150 || age \u0026lt; 0) { // 不合法  this.age = 3; }else { this.age = age; } } } 2 继承  继承的本质是对某一批 类 的抽象，从而实现对现实世界更加美好的建模。\n 2.1 extends 子类是父类的拓展，extends 可以理解为 is a，例如：\nStudent extends Person\n2.2 子类可以继承父类的所有方法 private不能访问，其余修饰符还有 public, protected, default\n2.3 Java 中类只有单继承，没有多继承 一个儿子只能有一个爸爸，一个爸爸可以有多个儿子\n2.4 object 类 在 Java 中，所有的类都默认直接或间接继承 object 类\n**IDEA查看继承关系的快捷键：**Ctrl + H\n// 父类 public class Person { private int money = 1_000_000_000; public void say() { System.out.println(\u0026#34;Say a word.\u0026#34;); } public int getMoney() { return money; } public void setMoney(int money) { this.money = money; } } // 子类 继承了父类 public class Student extends Person { } import Person; public class Application { public static void main(String[] args) { Student stu = new Student(); // 可以使用父类的方法  stu.say(); // 父类 private 的属性不能够直接修改  // System.out.println(stu.money); X  // 只能通过 get/set 访问  System.out.println(stu.getMoney()); } } 2.5 super   super调用父类的构造器方法，必须在子类构造器方法内的第一行\n  super只能在子类的方法或者构造器方法中使用\n（如果调用自己的super，那么会调用到object类去了）\n  super和this不能同时调用构造器方法，调用任意一个都要保证在第一行，所以肯定报错。默认情况下，super(); 在this(); 的内部第一行\n  // 父类 public class Person { // 这是父类的无参构造，如果需要有参构造，无参构造要用显式的(写出来)  public Person() { System.out.println(\u0026#34;Person的无参构造器执行了\u0026#34;); } protected String name = \u0026#34;Mike\u0026#34;; public void print() { System.out.println(\u0026#34;Person\u0026#34;); } } // 子类 继承了父类 public class Student extends Person { public Student() { // 隐藏代码：默认先调用了父类的无参构造器  // super(); 这句调用父类的构造器的代码，必须放在子类构造器的第一行！  // super(type arg); 也可以调用父类的有参数构造  // this(); this(type arg); 这些是this的构造器调用写法  System.out.println(\u0026#34;Student的无参构造器执行了\u0026#34;); } private String name = \u0026#34;Tim\u0026#34;; public void print() { System.out.println(\u0026#34;Student\u0026#34;); } public void testName(String name) { System.out.println(name); // 传入的参数 name  System.out.println(this.name); // Tim  System.out.println(super.name); // Mike  } public void testPrint() { print(); // 调用自己的print，不过没加 this. 有点表述模糊  this.print(); // Student  // 但如果是父类的是 private void print(){}，则无法调用  super.print(); // Person  } } import Person; import Student; public class Application { public static void main(String[] args) { Student stu = new Student(); // 测试 super  Student.testName(\u0026#34;Tom\u0026#34;); // Tom, Tim, Mike  Student.testPrint(); // Student, Student, Person  } } 2.6 this vs super     this super     代表的对象 本身调用者这个对象 代表父类对象的引用   前提 没有继承也可以使用 只能在继承条件下使用   构造方法 this(); 本类的构造 super(); 父类的构造    2.7 方法的重写(override) 简单来说，重写就是在子类中，把父类的方法再重写一遍，进行一些修改\n重写：需要有继承关系，子类重写父类的方法\n  子类父类的方法名必须相同\n  参数列表必须相同\n  修饰符：父类方法的范围可以比子类大，但不能缩小\npublic \u0026gt; protected \u0026gt; default \u0026gt; private\n  抛出的异常：范围可以被缩小，但不能扩大\nClassNotFoundException \u0026lt; Exception\n  为什么要重写？\n​\t父类的功能，子类不一定要需要，或者不一定满足\n**IDEA快捷键：**Alt + insert ，选 override\n非静态方法\n// 重写是方法的重写，与属性无关 public class B { // 是非静态的方法  public void test() { System.out.println(\u0026#34;B =\u0026gt; test()\u0026#34;); } } public class A extends B { @Override 注解：有功能的注释！ public void test() { System.out.println(\u0026#34;A =\u0026gt; test()\u0026#34;); } } import B; import A; public class Application { public static void main(String[] args) { A a = new A(); a.test(); // A =\u0026gt; test()  // 子类重写了父类的方法  B b = new A(); b.test(); // A =\u0026gt; test() 还是一样的，因为父类方法被重写了  } } 静态方法\npublic class B { // 是静态的方法  public static void test() { System.out.println(\u0026#34;B =\u0026gt; test()\u0026#34;); } } public class A extends B { public static void test() { System.out.println(\u0026#34;A =\u0026gt; test()\u0026#34;); } } import B; import A; public class Application { public static void main(String[] args) { A a = new A(); a.test(); // A =\u0026gt; test()  // 方法的调用只和 等号= 左边定义的数据类型有关  // 由于A继承了B，父类的引用指向了子类  B b = new A(); b.test(); // B =\u0026gt; test()  } } 3 多态 3.1 多态的概念   多态是方法的多态，属性没有多态\n  父类和子类，有联系才能转换类型\n无联系的类型转换会报错：ClassCastException\n  多态存在条件：\n继承关系，方法需要重写，父类类型 address指向子类对象 Father f1 = new Son();\n  关于无法重写：\nstatic 方法属于类，不属于实例，不能被重写\nfinal 属于常量，在常量池里，不能被重写\nprivate 方法，不能被重写\n  public class Person { // 父类独有  public void test() { System.out.println(\u0026#34;test\u0026#34;); } public void run() { System.out.println(\u0026#34;runP\u0026#34;); } } public class Student extends Person { // 子类独有  public void eat() { System.out.println(\u0026#34;eat\u0026#34;); } @Override // 子类重写了父类方法  public void run() { System.out.println(\u0026#34;runS\u0026#34;); } } import Person; import Student; public class Application { public static void main(String[] args) { // 一个对象的实际类型是确定的，new了什么就是什么  // new Student();  // new Person();  // 但可以指向对象的引用类型不确定  Student s1 = new Student(); // new了一个Student,但是类型是Person，address指向子类的对象  Person s2 = new Student(); Object s3 = new Student(); // 对象能执行哪些方法，看对象左边的类型，跟右边关系不大  // 父类类型只能调用父类方法，如果子类重写了，要注意输出结果  // 子类类型，不仅能调用自己的方法，还能调用继承来的父类方法  s1.eat(); // eat，类型是Student 才能调用子类里的eat();  // s2.eat(); 这样会报错  s1.test(); // test，类型是Student，继承了父类的test(); 可以调用  s2.test(); // test ，类型是Person 可以调用父类里的teat();  s2.run(); // runS ，因为子类重写了run(); 所以调用的是子类的run();  s1.run(); // runS ，类型是Student 可以调用子类的run();  } } 3.2 instanceof public class Person { public void run() { System.out.println(\u0026#34;run\u0026#34;); } } public class Teacher extends Person { } public class Student extends Person { public void go() { System.out.println(\u0026#34;go\u0026#34;); } } public class Application { public static void main(String[] args) { // 引用类型转换  Person object = new Student(); // object.go(); 会报错，父类类型 无法调用子类的方法  // 将这个对象转换为Student类型，就可以调用了  ((Student) object).go(); // 如果把子类类型转换为父类类型，会丢失自己独有的方法  Student student = new Student(); student.go(); // 子类类型 可以调用子类方法  Person person = student; // person.go(); 父类类型，无法调用子类独有方法了  // Object \u0026gt; String  // Object \u0026gt; Person \u0026gt; Teacher  // Object \u0026gt; Person \u0026gt; Student  // 编译是否成功，看引用类型 跟instanceof右边是否有关系  // true 还是 false，看地址实际指向对象 跟instanceof右边是否有关系  // 引用是Object类型，地址实际指向Student对象  Object obj = new Student(); System.out.println(obj instanceof Student); // true  System.out.println(obj instanceof Person); // true  System.out.println(obj instanceof Object); // true  // Student 和 Teacher 没关系，所以是false  System.out.println(obj instanceof Teacher); // false  // Student 和 String 没关系，所以是false  System.out.println(obj instanceof String); // false  // 引用是Person类型，地址实际指向Student对象  Person per = new Student(); System.out.println(per instanceof Student); // true  System.out.println(per instanceof Person); // true  System.out.println(per instanceof Object); // true  System.out.println(per instanceof Teacher); // false  // 编译报错！ Person 与 String 压根没关系  // System.out.println(per instanceof String);  // 引用是Student类型，地址也是指向Student对象  Student stu = new Student(); System.out.println(stu instanceof Student); // true  System.out.println(stu instanceof Person); // true  System.out.println(stu instanceof Object); // true  // 编译报错！ Student 与 Teacher 压根没关系  // System.out.println(stu instanceof Teacher);  // 编译报错！ Student 与 String 压根没关系  // System.out.println(stu instanceof String);  } } "
},
{
	"uri": "https://deemopoi.github.io/zh/b01-java%E5%85%A5%E9%97%A8/8-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_abstract-interface/",
	"title": "8 面向对象_abstract interface",
	"tags": [],
	"description": "",
	"content": "1 抽象类 abstract  抽象的抽象：约束\n   不能 new 这个抽象类，只能靠子类去实现它：约束\n  抽象类中可以写普通方法\n  抽象方法必须在抽象类中\n  // abstract 抽象类，本质是类，extends 只能单继承，不能多继承（而接口可以） public abstract calss Action { // 约束，有人帮我们实现  // abstract 抽象方法，只有方法名字，没有方法的实现  public abstract void doSomething(); // 抽象类里面的普通方法  public void run() { System.out.println(\u0026#34;run\u0026#34;); } } // 抽象类中的所有抽象方法，必须要继承了它的子类去重写，来实现这些方法； // 除非继承它的子类 A 也是个抽象类，那么就需要子类 A 的子类去实现了 public class A extends Action { @Override public void doSomething() { } } 2 接口 interface / implements  抽象类是抽象的抽象，是约束，抽象类有具体的实现（普通方法）和规范（抽象方法）；\n  接口只有规范，自己无法写方法，接口是专业的约束。\n接口的本质是契约，定义了一组规则，制定好后大家都遵守。\n   架构师其实就是拥有这种抽象的思维，能够把一个系统写成接口，然后让码农去实现这些方法。\n  接口不能被实例化，接口中没有构造方法。\n  // interface 定义的关键字， 接口都需要有实现类 public interface UserService { // 接口中定义的属性，都是常量，默认有 public static final，可省略  int AGE = 99; // 接口中的所有定义的方法，其实都是抽象的，默认有public avstract，可省略  void add(String name); void delete(String name); void undate(String name); void query(String name); } public interface TimeService { void timer(); } // 抽象类，extends 只能单继承；而接口可以多继承 // 实现了接口的类，就需要重写接口中的方法 // 类 + 可以实现接口 + implements + 接口1,接口2 public class UserServiceImpl implements UverService,TimeService { @Override public void add(String name) { } @Override public void delete(String name) { } @Override public void update(String name) { } @Override public void query(String name) { } @Override public void timer() { } } "
},
{
	"uri": "https://deemopoi.github.io/zh/b01-java%E5%85%A5%E9%97%A8/9-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_static-%E5%86%85%E9%83%A8%E7%B1%BB-%E8%8A%B1%E5%BC%8F%E5%86%99%E6%B3%95/",
	"title": "9 面向对象_static 内部类 花式写法",
	"tags": [],
	"description": "",
	"content": "1 static 1.1 静态属性和静态方法\npublic class Student { private static int age; // 静态变量  private double score; // 非静态变量  public static void go() { } public void run() { } public static void main(String[] args) { Student s1 = new Student(); System.out.println(Student.age); // System.out.println(Student.score); 非静态，不能直接调用  System.out.println(s1.age); System.out.println(s1.score); Student.go(); // 或者 go();  s1.run(); } } 1.2 静态代码块\npublic class Person { // 2 也可以用来赋初始值  { System.out.println(\u0026#34;匿名代码块\u0026#34;)； } // 1 只执行一次  static { System.out.println(\u0026#34;静态代码块\u0026#34;)； } // 3  public Person() { System.out.println(\u0026#34;构造方法\u0026#34;)； } public static void main(String[] args) { Person p1 = new Person(); System.out.println(\u0026#34;###########\u0026#34;); Person p2 = new Person(); } // output: // 静态代码块 // 匿名代码块 // 构造方法 // ########### // 匿名代码块 // 构造方法 1.3 静态导入包 public class Test { public static void main(String[] args) { System.out.println(Math.random()); System.out.println(Math.PI); } } // 静态导入包 import static java.lang.Math.random; import static java.lang.Math.PI; public class Test { public static void main(String[] args) { // 可以省略 Math.  System.out.println(random()); System.out.println(PI); } } 1.4 final // 如果 Person 被 final 修饰了，就不能被继承了（断子绝孙） public final class Person { } 2 内部类 // 外部类 public class Outer { private int id = 10; public void out() { System.out.println(\u0026#34;这是外部类的方法\u0026#34;)； } // 内部类  public class Inner { public void in() { System.out.println(\u0026#34;这是内部类的方法\u0026#34;)； } // 内部类可以直接访问外部类的 私有(private)属性/方法  public void getId() { System.out.println(id)； } } // 静态类因为在外部类实例化之前就已经加载了，所以无法访问外部类的 非静态属性/方法了  public static class Inner2 { public void in() { System.out.println(\u0026#34;这是内部类的方法\u0026#34;)； } } } public class Application { public static void main(String[] args) { // new 一个外部类  Outer outer = new Outer(); // 通过外部类，来实例化它的内部类  Outer.Inner inner = outer.new Inner(); // 可以调用内部类的方法了  inner.in(); } } 3 类的花式写法 3.1 多个class\npublic class Outer { } // 一个Java文件中可以有多个class类，但是只能有一个 public class class A { public static void main(String[] args) { } } 3.2 局部内部类\npublic class Outer { // 局部内部类，方法里的类（可以类比局部变量）  public void method() { class Inner { public void in() { } } } } 3.3 匿名对象\npublic class Test { public static void main(String[] args) { // 没有名字 初始化类，不用将实例的地址保存到变量中  new Apple().eat(); // 接口不能new，这里的new相当于接口的实现类，但是这个类没有名字  new UserService() { @Override public void hello() { } } } } class Apple { public void eat() { System.out.println(\u0026#34;1\u0026#34;); } } interface UserService { void hello(); } "
},
{
	"uri": "https://deemopoi.github.io/zh/b01-java%E5%85%A5%E9%97%A8/10-%E5%BC%82%E5%B8%B8/",
	"title": "10 异常",
	"tags": [],
	"description": "",
	"content": "1 异常分类 1.1 异常的分类  检查性异常：用户错误或问题导致，程序员无法预见，例如打开一个不存在的文件 运行时异常：可以被程序员避免的异常，编译的时候看不到，只有运行了才知道 错误Error：错误不是异常，而是脱离程序员控制的问题，例如stack overflow  1.2 异常体系结构   Error 程序无法控制和处理，可能导致Java虚拟机(JVM) 终止线程，强行关掉，后果严重\n  Exception 一般是可以被程序处理的，并且在程序中应该尽可能去处理这些异常\n​\t- RuntimeException\n​\t- Non-RuntimeException\n  2 异常处理机制   抛出异常\n  捕获异常\n  **异常处理的五个关键词：**try, catch, finally, throw, throws\n**IDEA快捷键：**选中想要监控的代码 Ctrl + Alt + T\n2.1 try, catch, finally public class Test { public void a() { b(); } public void b() { a(); } public static void main(String[] args) { int a = 1; int b = 0; try { // try 监控区域（此处可能会出现异常）  System.out.println(a/b); }catch (ArithmeticException e) { // catch 捕获异常  // 可以增加一些处理异常的代码，而不是简单报错  System.out.println(\u0026#34;程序出现异常，变量b不能为0\u0026#34;); e.printStackTrace(); // 打印出错的栈信息  }finally { // finally 处理善后工作（无论是否有异常，都会执行）  System.out.println(\u0026#34;finally\u0026#34;); } // finally 可以不要  // 假设要捕获多个异常，捕获范围要从小到大  try { new Test().a(); }catch(Error e) { System.out.println(\u0026#34;Erro\u0026#34;); }catch(Exception e) { System.out.println(\u0026#34;Exception\u0026#34;); }catch(Throwable t) { System.out.println(\u0026#34;Throwable\u0026#34;); }finally { System.out.println(\u0026#34;finally\u0026#34;); } } } 2.2 throw, throws public class Test { public void test1(int a, int b) { if (b == 0) { // throw  throw new ArithmeticException(); // 主动抛出异常，一般在方法中使用  } System.out.println(a/b); } // 假设在方法中，处理不了这个异常，可以用throws，从方法上抛出异常  public void test2(int a, int b) throws ArithmeticException { if (b == 0) { throw new ArithmeticException(); } System.out.println(a/b); } public static void main(String[] args) { // 这个会在方法内主动抛出异常 throw  new Test().test1(1, 0); // 这个是方法内处理不了，在方法上抛出异常 throws  // 然后用try catch 捕获，以让程序继续运行  try { new Test().test2(1, 0); }catch (ArithmeticException e) { e.printStackTrace(); } } } 3 自定义异常 使用Java内置的异常类可以描述在编程时出现的大部分异常。除此之外，用户可以自定义异常。\n用户自定义异常类，只需要继承Exception类即可。\n// 自定义异常类 public class MyException extends Exception { private int detail; // 传递数字 a \u0026gt; 10 给 detail  public MyException(int a) { this.detail = a; } // toString: 异常的打印信息  @Override public String toString() { return \u0026#34;MyException{\u0026#34; + detail + \u0026#34;}\u0026#34;; } } // 测试类 public class Test { // 可能会存在异常的方法  static void test(int a) throws MyException { System.out.println(\u0026#34;传递的参数为：\u0026#34; + a); if (a \u0026gt; 10) { throw new MyException(a); } System.out.println(\u0026#34;OK\u0026#34;); } public static void main(String[] args) { // a == 11 会触发test()方法里的throw，主动抛出一个 new MyException(11)  // 调用 MyException类 里的 MyException(11) 方法，把11赋值给detail  // 与此同时 MyException 被 catch捕获，执行打印操作  // 其中的 e 会调用 MyException类里的 toString()方法(已经被重写)  // 所以会打印出:  // 传递参数为：11  // MyException =\u0026gt; MyException{11}  try { test(11); }catch (MyException e) { System.out.println(\u0026#34;MyException =\u0026gt; \u0026#34; + e); } } } 4 经验总结  处理运行异常时，采用逻辑去合理规避异常，同时用 try-catch 辅助处理，让程序继续运行 在多重catch块最后，尽可能加一个 catch(Exception) 来处理可能会被遗漏的异常 对于不确定的代码，也可以加上 try-catch，处理潜在异常 尽量去处理异常，尝试补救，切忌只是简单地调用 printStackTrack() 去打印输出 尽量添加 finally 语句去释放占用的资源  "
},
{
	"uri": "https://deemopoi.github.io/zh/b01-java%E5%85%A5%E9%97%A8/",
	"title": "B01 Java入门",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://deemopoi.github.io/zh/b03-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/",
	"title": "B03 汇编语言",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://deemopoi.github.io/zh/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "DeemoPoi\u0026rsquo;s Notes "
},
{
	"uri": "https://deemopoi.github.io/zh/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://deemopoi.github.io/zh/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]